

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\books_categories.py =====

from sqlalchemy.orm import Session
from app.models.books_categories import BookCategory
from app.schemas.books_categories import BookCategoryCreate

def create_category(db: Session, category: BookCategoryCreate):
    db_category = BookCategory(**category.dict())
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

def get_categories(db: Session, skip: int = 0, limit: int = 100):
    return db.query(BookCategory).offset(skip).limit(limit).all()

def get_category_by_name(db: Session, name: str):
    return db.query(BookCategory).filter(BookCategory.name == name).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\literature.py =====

from sqlalchemy.orm import Session
from app.models.literature_works import LiteratureWork
from app.models.books_editions import BookEdition
from app.schemas.literature import LiteratureWorkCreate, BookEditionCreate
from sqlalchemy import or_

# --- LiteratureWork ---
def create_literature_work(db: Session, work: LiteratureWorkCreate):
    db_work = LiteratureWork(**work.dict())
    db.add(db_work)
    db.commit()
    db.refresh(db_work)
    return db_work

def get_literature_work(db: Session, work_id: int):
    return db.query(LiteratureWork).filter(LiteratureWork.id == work_id).first()

def get_literature_works(db: Session, skip: int = 0, limit: int = 100):
    return db.query(LiteratureWork).offset(skip).limit(limit).all()


# --- BookEdition ---
def create_book_edition(db: Session, edition: BookEditionCreate):
    db_edition = BookEdition(**edition.dict())
    db.add(db_edition)
    db.commit()
    db.refresh(db_edition)
    return db_edition

def get_book_edition(db: Session, edition_id: int):
    return db.query(BookEdition).filter(BookEdition.id == edition_id).first()

def get_book_editions(db: Session, skip: int = 0, limit: int = 100):
    return db.query(BookEdition).offset(skip).limit(limit).all()

def search_books(db: Session, query: str, limit: int = 10):
    search_term = f"%{query}%"

    return (
        db.query(BookEdition)
        .join(LiteratureWork)
        .filter(
            or_(
                LiteratureWork.title.ilike(search_term),
                LiteratureWork.author.ilike(search_term)
            )
        )
        .limit(limit)
        .all()
    )

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_book_notes.py =====

from sqlalchemy.orm import Session
from app.models.users_book_notes import UserBookNote
from app.schemas.users_book_notes import UserBookNoteCreate

def create_note(db: Session, note: UserBookNoteCreate):
    db_note = UserBookNote(**note.dict())
    db.add(db_note)
    db.commit()
    db.refresh(db_note)
    return db_note

def get_notes(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserBookNote).offset(skip).limit(limit).all()

def get_note(db: Session, note_id: int):
    return db.query(UserBookNote).filter(UserBookNote.id == note_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_book_quotes.py =====

from sqlalchemy.orm import Session
from app.models.users_book_quotes import UserBookQuote
from app.schemas.users_book_quotes import UserBookQuoteCreate

def create_quote(db: Session, quote: UserBookQuoteCreate):
    db_quote = UserBookQuote(**quote.dict())
    db.add(db_quote)
    db.commit()
    db.refresh(db_quote)
    return db_quote

def get_quotes(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserBookQuote).offset(skip).limit(limit).all()

def get_quote(db: Session, quote_id: int):
    return db.query(UserBookQuote).filter(UserBookQuote.id == quote_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_book_rating.py =====

from sqlalchemy.orm import Session
from app.models.users_book_rating import UserBookRating
from app.schemas.users_book_rating import UserBookRatingCreate

def create_rating(db: Session, rating: UserBookRatingCreate):
    db_rating = UserBookRating(**rating.dict())
    db.add(db_rating)
    db.commit()
    db.refresh(db_rating)
    return db_rating

def get_ratings(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserBookRating).offset(skip).limit(limit).all()

def get_rating(db: Session, rating_id: int):
    return db.query(UserBookRating).filter(UserBookRating.id == rating_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_book_review.py =====

# app/crud/users_book_review.py
from sqlalchemy.orm import Session
from sqlalchemy.orm import joinedload
from app.models.users_book_review import UserBookReview
from app.schemas.users_book_review import UserBookReviewCreate
from app.models.literature_works import LiteratureWork
from app.models.books_editions import BookEdition
from app.models.books_categories import BookCategory
from app.schemas.custom_book import BookManualCreate
from app.models.genre import Genre

def create_review(db: Session, review: UserBookReviewCreate) -> UserBookReview:
    db_review = UserBookReview(**review.dict())
    db.add(db_review)
    db.commit()
    db.refresh(db_review)
    return db_review

def get_reviews(db: Session, skip: int = 0, limit: int = 100):
    return (
        db.query(UserBookReview)
        .options(
            joinedload(UserBookReview.category),
            joinedload(UserBookReview.rating),
            joinedload(UserBookReview.user),
            joinedload(UserBookReview.quotes),
            joinedload(UserBookReview.notes)
            # Добавь joinedload для всех полей, которые нужны в ответе
        )
        .offset(skip)
        .limit(limit)
        .all()
    )
def get_review_by_id(db: Session, review_id: int):
    return db.query(UserBookReview).filter(UserBookReview.id == review_id).first()

def get_user_reviews_by_category_name(db: Session, user_id: int, category_name: str):
    return (
        db.query(UserBookReview)
        .join(UserBookReview.category)
        .filter(UserBookReview.user_id == user_id)
        .filter(UserBookReview.category.has(name=category_name))
        .all()
    )

def delete_review(db: Session, review_id: int) -> bool:
    obj = db.query(UserBookReview).filter(UserBookReview.id == review_id).first()
    if not obj:
        return False
    db.delete(obj)
    db.commit()
    return True

def get_user_library(db: Session, user_id: int, skip: int = 0, limit: int = 100):
    return (
        db.query(UserBookReview)
        .options(
            # Теперь Python знает, что такое BookEdition
            joinedload(UserBookReview.book).joinedload(BookEdition.work),
            joinedload(UserBookReview.category),
            joinedload(UserBookReview.rating)
        )
        .filter(UserBookReview.user_id == user_id)
        .offset(skip)
        .limit(limit)
        .all()
    )

def create_manual_book_review(db: Session, user_id: int, data: BookManualCreate):
    # 1. Ищем категорию (она должна существовать)
    category = db.query(BookCategory).filter(BookCategory.name == data.category_name).first()
    if not category:
        # Если категории нет, можно либо вернуть ошибку, либо создать дефолтную.
        # Для надежности вернем None, фронт должен слать правильные названия.
        return None

    # 2. Создаем Литературное произведение
    # (В будущем здесь можно добавить проверку: если такое название+автор есть, не создавать дубль)
    new_work = LiteratureWork(
        title=data.title,
        author=data.author
    )
    db.add(new_work)
    db.flush()  # flush позволяет получить id созданного объекта до commit

    # 3. Создаем Издание книги
    new_edition = BookEdition(
        literature_work_id=new_work.id,
        pages=data.pages,
        year=data.year,
        language=data.language,
        description=data.description,
        cover_url=data.cover_url
    )
    db.add(new_edition)
    db.flush()

    # 4. Создаем Отзыв пользователя (связь)
    new_review = UserBookReview(
        user_id=user_id,
        book_id=new_edition.id,
        category_id=category.id
    )
    db.add(new_review)

    db.commit()
    db.refresh(new_review)

    return new_review

def get_review_detail(db: Session, review_id: int):
    return (
        db.query(UserBookReview)
        .options(
            joinedload(UserBookReview.book).joinedload(BookEdition.work),
            joinedload(UserBookReview.category),
            joinedload(UserBookReview.rating),
            joinedload(UserBookReview.quotes),
            joinedload(UserBookReview.notes),
            # Для жанров сложнее, так как это many-to-many через таблицу связку
            joinedload(UserBookReview.genres).joinedload(UserBookReviewGenre.genre)
        )
        .filter(UserBookReview.id == review_id)
        .first()
    )

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_book_review_genres.py =====

from sqlalchemy.orm import Session
from app.models.users_book_review_genres import UserBookReviewGenre
from app.schemas.users_book_review_genres import UserBookReviewGenreCreate

def create_review_genre(db: Session, entry: UserBookReviewGenreCreate):
    db_entry = UserBookReviewGenre(**entry.dict())
    db.add(db_entry)
    db.commit()
    db.refresh(db_entry)
    return db_entry

def get_review_genres(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserBookReviewGenre).offset(skip).limit(limit).all()

def get_review_genre(db: Session, entry_id: int):
    return db.query(UserBookReviewGenre).filter(UserBookReviewGenre.id == entry_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_challenges.py =====

from sqlalchemy.orm import Session
from app.models.users_challenges import UserChallenge
from app.schemas.users_challenges import UserChallengeCreate

def create_challenge(db: Session, challenge: UserChallengeCreate):
    db_challenge = UserChallenge(**challenge.dict())
    db.add(db_challenge)
    db.commit()
    db.refresh(db_challenge)
    return db_challenge

def get_challenges(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserChallenge).offset(skip).limit(limit).all()

def get_challenge(db: Session, challenge_id: int):
    return db.query(UserChallenge).filter(UserChallenge.id == challenge_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_challenge_books_alphabet.py =====

from sqlalchemy.orm import Session
from app.models.users_challenge_books_alphabet import UserChallengeBooksAlphabet
from app.schemas.users_challenge_books_alphabet import UserChallengeBooksAlphabetCreate

def create_alphabet_entry(db: Session, entry: UserChallengeBooksAlphabetCreate):
    db_entry = UserChallengeBooksAlphabet(**entry.dict())
    db.add(db_entry)
    db.commit()
    db.refresh(db_entry)
    return db_entry

def get_alphabet_entries(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserChallengeBooksAlphabet).offset(skip).limit(limit).all()

def get_alphabet_entry(db: Session, entry_id: int):
    return db.query(UserChallengeBooksAlphabet).filter(UserChallengeBooksAlphabet.id == entry_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_challenge_book_of_year.py =====

from sqlalchemy.orm import Session
from app.models.users_challenge_book_of_year import UserChallengeBookOfYear
from app.schemas.users_challenge_book_of_year import UserChallengeBookOfYearCreate

def create_entry(db: Session, entry: UserChallengeBookOfYearCreate):
    db_entry = UserChallengeBookOfYear(**entry.dict())
    db.add(db_entry)
    db.commit()
    db.refresh(db_entry)
    return db_entry

def get_entries(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserChallengeBookOfYear).offset(skip).limit(limit).all()

def get_entry(db: Session, entry_id: int):
    return db.query(UserChallengeBookOfYear).filter(UserChallengeBookOfYear.id == entry_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_personal_data.py =====

from sqlalchemy.orm import Session
from app.models.users_personal_data import UserPersonalData
from app.schemas.users_personal_data import UserPersonalDataCreate
from passlib.context import CryptContext
from app.utils.email import generate_verification_code, send_verification_email

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def create_user(db: Session, user: UserPersonalDataCreate):
    hashed_password = pwd_context.hash(user.password_hash)

    code = generate_verification_code()

    db_user = UserPersonalData(
        username=user.username,
        email=user.email,
        password_hash=hashed_password,
        agreement_accepted=user.agreement_accepted,
        profile_photo=user.profile_photo,
        verification_code=code,
        is_verified=False
    )

    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    send_verification_email(user.email, code)

    return db_user

def verify_user_email(db: Session, email: str, code: str):
    user = get_user_by_email(db, email)
    if not user:
        return None

    if user.verification_code == code:
        user.is_verified = True
        user.verification_code = None
        db.commit()
        db.refresh(user)
        return user

    return False

def get_users(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserPersonalData).offset(skip).limit(limit).all()


def get_user_by_id(db: Session, user_id: int):
    return db.query(UserPersonalData).filter(UserPersonalData.id == user_id).first()


def get_user_by_email(db: Session, email: str):
    return db.query(UserPersonalData).filter(UserPersonalData.email == email).first()

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_reading_records.py =====

from sqlalchemy.orm import Session
from app.models.users_reading_records import UserReadingRecord
from app.schemas.users_reading_records import UserReadingRecordCreate

def create_record(db: Session, record: UserReadingRecordCreate):
    db_record = UserReadingRecord(**record.dict())
    db.add(db_record)
    db.commit()
    db.refresh(db_record)
    return db_record

def get_records(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserReadingRecord).offset(skip).limit(limit).all()

def get_record(db: Session, record_id: int):
    return db.query(UserReadingRecord).filter(UserReadingRecord.id == record_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_statistics.py =====

from sqlalchemy.orm import Session
from app.models.users_statistics import UserStatistics
from app.schemas.users_statistics import UserStatisticsCreate

def create_statistics(db: Session, stats: UserStatisticsCreate):
    db_stats = UserStatistics(**stats.dict())
    db.add(db_stats)
    db.commit()
    db.refresh(db_stats)
    return db_stats

def get_statistics(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserStatistics).offset(skip).limit(limit).all()

def get_statistics_by_id(db: Session, stats_id: int):
    return db.query(UserStatistics).filter(UserStatistics.id == stats_id).first()

def get_statistics_by_user_id(db: Session, user_id: int):
    return db.query(UserStatistics).filter(UserStatistics.user_id == user_id).first()

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\users_top_characters.py =====

from sqlalchemy.orm import Session
from app.models.users_top_characters import UserTopCharacters
from app.schemas.users_top_characters import UserTopCharactersCreate

def create_top_characters(db: Session, top_chars: UserTopCharactersCreate):
    db_top_chars = UserTopCharacters(**top_chars.dict())
    db.add(db_top_chars)
    db.commit()
    db.refresh(db_top_chars)
    return db_top_chars

def get_top_characters(db: Session, skip: int = 0, limit: int = 100):
    return db.query(UserTopCharacters).offset(skip).limit(limit).all()

def get_top_characters_by_id(db: Session, record_id: int):
    return db.query(UserTopCharacters).filter(UserTopCharacters.id == record_id).first()


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\crud\__init__.py =====

