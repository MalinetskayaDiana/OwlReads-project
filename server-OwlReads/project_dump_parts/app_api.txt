

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\auth.py =====

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from pydantic import BaseModel, EmailStr

from app.db.session import get_db
from app.crud import users_personal_data as crud
from app.core.security import verify_password, create_access_token

router = APIRouter()

class LoginSchema(BaseModel):
    email: EmailStr
    password: str


@router.post("/login")
def login(login_data: LoginSchema, db: Session = Depends(get_db)):
    # 1. Ищем пользователя по email
    user = crud.get_user_by_email(db, email=login_data.email)

    # 2. Если пользователя нет ИЛИ пароль не подходит
    if not user or not verify_password(login_data.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный email или пароль",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 3. Если всё ок, создаем токен
    access_token = create_access_token(data={"sub": str(user.id)})

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user_id": user.id,
        "username": user.username
    }

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\books_categories.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.books_categories import BookCategory, BookCategoryCreate
from app.crud import books_categories as crud

router = APIRouter()

@router.post("/", response_model=BookCategory, status_code=201)
def create_category(category: BookCategoryCreate, db: Session = Depends(get_db)):
    db_category = crud.get_category_by_name(db, category.name)
    if db_category:
        raise HTTPException(status_code=400, detail="Category already exists")
    return crud.create_category(db, category)

@router.get("/", response_model=List[BookCategory])
def read_categories(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_categories(db, skip=skip, limit=limit)


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\genre.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.db.session import get_db   # <-- теперь импортируем отсюда
from app.models.genre import Genre as GenreModel
from app.schemas.genre import GenreRead

router = APIRouter()

@router.get("/", response_model=list[GenreRead])
def list_genres(db: Session = Depends(get_db)):
    return db.query(GenreModel).order_by(GenreModel.id).all()

@router.get("/{genre_id}/", response_model=GenreRead)
def get_genre(genre_id: int, db: Session = Depends(get_db)):
    genre = db.query(GenreModel).get(genre_id)
    if not genre:
        raise HTTPException(status_code=404, detail="Genre not found")
    return genre


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\literature.py =====

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List
from app.schemas.literature import LiteratureWork, LiteratureWorkCreate, BookEdition, BookEditionCreate
from app.crud import literature as crud
from app.db.session import get_db
from app.schemas.literature import BookSearchResponse

router = APIRouter()

# --- LiteratureWork ---
@router.post("/works", response_model=LiteratureWork)
def create_work(work: LiteratureWorkCreate, db: Session = Depends(get_db)):
    return crud.create_literature_work(db, work)

@router.get("/works", response_model=List[LiteratureWork])
def read_works(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_literature_works(db, skip=skip, limit=limit)

@router.get("/works/{work_id}", response_model=LiteratureWork)
def read_work(work_id: int, db: Session = Depends(get_db)):
    return crud.get_literature_work(db, work_id)


# --- BookEdition ---
@router.post("/editions", response_model=BookEdition)
def create_edition(edition: BookEditionCreate, db: Session = Depends(get_db)):
    return crud.create_book_edition(db, edition)

@router.get("/editions", response_model=List[BookEdition])
def read_editions(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_book_editions(db, skip=skip, limit=limit)

@router.get("/editions/{edition_id}", response_model=BookEdition)
def read_edition(edition_id: int, db: Session = Depends(get_db)):
    return crud.get_book_edition(db, edition_id)

@router.get("/search", response_model=List[BookSearchResponse])
def search_books_endpoint(q: str, db: Session = Depends(get_db)):
    if not q:
        return []

    books = crud.search_books(db, query=q)

    # Преобразуем ORM модели в Pydantic схему вручную или автоматически
    results = []
    for book in books:
        results.append(BookSearchResponse(
            id=book.id,
            title=book.work.title,  # Берем название из связанной таблицы
            author=book.work.author,  # Берем автора из связанной таблицы
            cover_url=book.cover_url,
            year=book.year,
            source="local"
        ))
    return results

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\popular_quotes.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy.sql.expression import func  # <--- Импортируем func для SQL функций

from app.db.session import get_db
from app.models.popular_quotes import PopularQuote as PopularQuoteModel
from app.schemas.popular_quotes import PopularQuoteCreate, PopularQuote as PopularQuoteSchema

router = APIRouter()


@router.post("/", response_model=PopularQuoteSchema, status_code=201)
def create_quote(quote: PopularQuoteCreate, db: Session = Depends(get_db)):
    db_quote = PopularQuoteModel(**quote.dict())
    db.add(db_quote)
    db.commit()
    db.refresh(db_quote)
    return db_quote


@router.get("/", response_model=list[PopularQuoteSchema])
def get_quotes(db: Session = Depends(get_db)):
    return db.query(PopularQuoteModel).all()


@router.get("/{quote_id}/", response_model=PopularQuoteSchema)
def get_quote(quote_id: int, db: Session = Depends(get_db)):
    quote = db.query(PopularQuoteModel).get(quote_id)
    if not quote:
        raise HTTPException(status_code=404, detail="Quote not found")
    return quote

@router.get("/random", response_model=PopularQuoteSchema)
def get_random_quote(db: Session = Depends(get_db)):
    quote = db.query(PopularQuoteModel).order_by(func.random()).first()

    if not quote:
        raise HTTPException(status_code=404, detail="No quotes found in database")

    return quote

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_book_notes.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_book_notes import UserBookNote, UserBookNoteCreate
from app.crud import users_book_notes as crud

router = APIRouter()

@router.post("/", response_model=UserBookNote, status_code=201)
def create_note(note: UserBookNoteCreate, db: Session = Depends(get_db)):
    return crud.create_note(db, note)

@router.get("/", response_model=List[UserBookNote])
def read_notes(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_notes(db, skip=skip, limit=limit)

@router.get("/{note_id}/", response_model=UserBookNote)
def read_note(note_id: int, db: Session = Depends(get_db)):
    note = crud.get_note(db, note_id)
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    return note


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_book_quotes.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_book_quotes import UserBookQuote, UserBookQuoteCreate
from app.crud import users_book_quotes as crud

router = APIRouter()

@router.post("/", response_model=UserBookQuote, status_code=201)
def create_quote(quote: UserBookQuoteCreate, db: Session = Depends(get_db)):
    return crud.create_quote(db, quote)

@router.get("/", response_model=List[UserBookQuote])
def read_quotes(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_quotes(db, skip=skip, limit=limit)

@router.get("/{quote_id}/", response_model=UserBookQuote)
def read_quote(quote_id: int, db: Session = Depends(get_db)):
    quote = crud.get_quote(db, quote_id)
    if not quote:
        raise HTTPException(status_code=404, detail="Quote not found")
    return quote


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_book_rating.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_book_rating import UserBookRating, UserBookRatingCreate
from app.crud import users_book_rating as crud

router = APIRouter()

@router.post("/", response_model=UserBookRating, status_code=201)
def create_rating(rating: UserBookRatingCreate, db: Session = Depends(get_db)):
    return crud.create_rating(db, rating)

@router.get("/", response_model=List[UserBookRating])
def read_ratings(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_ratings(db, skip=skip, limit=limit)

@router.get("/{rating_id}/", response_model=UserBookRating)
def read_rating(rating_id: int, db: Session = Depends(get_db)):
    rating = crud.get_rating(db, rating_id)
    if not rating:
        raise HTTPException(status_code=404, detail="Rating not found")
    return rating


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_book_review.py =====

# app/api/users_book_review.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_book_review import UserBookReview, UserBookReviewCreate, LibraryBookRead
from app.crud import users_book_review as crud

from app.schemas.custom_book import BookManualCreate
from app.schemas.users_book_review import BookReviewDetail
from app.schemas.genre import GenreRead

router = APIRouter()

@router.post("/reviews", response_model=UserBookReview, status_code=201)
def create_review(review: UserBookReviewCreate, db: Session = Depends(get_db)):
    return crud.create_review(db, review)

@router.get("/reviews", response_model=List[UserBookReview])
def read_reviews(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_reviews(db, skip=skip, limit=limit)

@router.get("/reviews/{review_id}/", response_model=UserBookReview)
def read_review(review_id: int, db: Session = Depends(get_db)):
    review = crud.get_review_by_id(db, review_id)
    if not review:
        raise HTTPException(status_code=404, detail="Review not found")
    return review

@router.get("/users/{user_id}/reviews/by_category", response_model=List[UserBookReview])
def read_user_reviews_by_category(
    user_id: int,
    category_name: str = Query(..., description="Название категории, например: Прочитано"),
    db: Session = Depends(get_db),
):
    results = crud.get_user_reviews_by_category_name(db, user_id, category_name)
    return results

@router.delete("/reviews/{review_id}/", status_code=204)
def delete_review(review_id: int, db: Session = Depends(get_db)):
    ok = crud.delete_review(db, review_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Review not found")
    return None


@router.post("/manual", status_code=201)
def add_book_manually(
        book_data: BookManualCreate,
        user_id: int = Query(..., description="ID пользователя"),
        db: Session = Depends(get_db)
):
    review = crud.create_manual_book_review(db, user_id, book_data)
    if not review:
        raise HTTPException(status_code=400, detail="Category not found or error creating book")

    return {"message": "Book added successfully", "review_id": review.id}


@router.get("/library/{user_id}", response_model=List[LibraryBookRead])
def read_user_library(user_id: int, skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    reviews = crud.get_user_library(db, user_id, skip, limit)

    results = []
    for review in reviews:
        # Защита от ошибок, если вдруг данных нет
        book_title = review.book.work.title if review.book and review.book.work else "Без названия"
        book_author = review.book.work.author if review.book and review.book.work else "Неизвестный автор"
        cover = review.book.cover_url if review.book else None
        cat_name = review.category.name if review.category else "Без категории"

        # Логика цвета
        color = "#AB66FF"  # Дефолтный
        if cat_name == "Хочу прочитать":
            color = "#66A3FF"
        elif cat_name == "Читаю":
            color = "#FFB066"
        elif cat_name == "Брошено":
            color = "#FF6666"
        elif cat_name == "Любимые":
            color = "#FF66B3"

        rating_val = review.rating.total_rating if review.rating else 0

        results.append(LibraryBookRead(
            review_id=review.id,
            book_id=review.book_id,
            title=book_title,
            author=book_author,
            cover_url=cover,
            category_name=cat_name,
            category_color=color,
            rating=rating_val
        ))
    return results


@router.get("/{review_id}", response_model=BookReviewDetail)
def read_review_detail(review_id: int, db: Session = Depends(get_db)):
    review = crud.get_review_detail(db, review_id)
    if not review:
        raise HTTPException(status_code=404, detail="Review not found")

    # Собираем жанры из связующей таблицы
    genres_list = [g.genre for g in review.genres] if review.genres else []

    return BookReviewDetail(
        review_id=review.id,
        book_id=review.book.id,
        title=review.book.work.title,
        author=review.book.work.author,
        pages=review.book.pages,
        year=review.book.year,
        description=review.book.description,
        cover_url=review.book.cover_url,
        category_name=review.category.name,
        rating=review.rating,
        quotes=review.quotes,
        notes=review.notes,
        genres=genres_list  # Pydantic сам преобразует в GenreRead
    )

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_book_review_genres.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_book_review_genres import UserBookReviewGenre, UserBookReviewGenreCreate
from app.crud import users_book_review_genres as crud

router = APIRouter()

@router.post("/", response_model=UserBookReviewGenre, status_code=201)
def create_review_genre(entry: UserBookReviewGenreCreate, db: Session = Depends(get_db)):
    return crud.create_review_genre(db, entry)

@router.get("/", response_model=List[UserBookReviewGenre])
def read_review_genres(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_review_genres(db, skip=skip, limit=limit)

@router.get("/{entry_id}/", response_model=UserBookReviewGenre)
def read_review_genre(entry_id: int, db: Session = Depends(get_db)):
    entry = crud.get_review_genre(db, entry_id)
    if not entry:
        raise HTTPException(status_code=404, detail="ReviewGenre entry not found")
    return entry


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_challenges.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_challenges import UserChallenge, UserChallengeCreate
from app.crud import users_challenges as crud

router = APIRouter()

@router.post("/", response_model=UserChallenge, status_code=201)
def create_challenge(challenge: UserChallengeCreate, db: Session = Depends(get_db)):
    return crud.create_challenge(db, challenge)

@router.get("/", response_model=List[UserChallenge])
def read_challenges(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_challenges(db, skip=skip, limit=limit)

@router.get("/{challenge_id}/", response_model=UserChallenge)
def read_challenge(challenge_id: int, db: Session = Depends(get_db)):
    challenge = crud.get_challenge(db, challenge_id)
    if not challenge:
        raise HTTPException(status_code=404, detail="Challenge not found")
    return challenge


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_challenge_books_alphabet.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_challenge_books_alphabet import UserChallengeBooksAlphabet, UserChallengeBooksAlphabetCreate
from app.crud import users_challenge_books_alphabet as crud

router = APIRouter()

@router.post("/alphabet", response_model=UserChallengeBooksAlphabet, status_code=201)
def create_alphabet_entry(entry: UserChallengeBooksAlphabetCreate, db: Session = Depends(get_db)):
    return crud.create_alphabet_entry(db, entry)

@router.get("/alphabet", response_model=List[UserChallengeBooksAlphabet])
def read_alphabet_entries(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_alphabet_entries(db, skip=skip, limit=limit)

@router.get("/alphabet/{entry_id}/", response_model=UserChallengeBooksAlphabet)
def read_alphabet_entry(entry_id: int, db: Session = Depends(get_db)):
    entry = crud.get_alphabet_entry(db, entry_id)
    if not entry:
        raise HTTPException(status_code=404, detail="Alphabet entry not found")
    return entry


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_challenge_book_of_year.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_challenge_book_of_year import UserChallengeBookOfYear, UserChallengeBookOfYearCreate
from app.crud import users_challenge_book_of_year as crud

router = APIRouter()

@router.post("/book_of_year", response_model=UserChallengeBookOfYear, status_code=201)
def create_entry(entry: UserChallengeBookOfYearCreate, db: Session = Depends(get_db)):
    return crud.create_entry(db, entry)

@router.get("/book_of_year", response_model=List[UserChallengeBookOfYear])
def read_entries(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_entries(db, skip=skip, limit=limit)

@router.get("/book_of_year/{entry_id}/", response_model=UserChallengeBookOfYear)
def read_entry(entry_id: int, db: Session = Depends(get_db)):
    entry = crud.get_entry(db, entry_id)
    if not entry:
        raise HTTPException(status_code=404, detail="Book of Year entry not found")
    return entry


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_personal_data.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_personal_data import UserPersonalData, UserPersonalDataCreate, UserVerifyEmail
from app.crud import users_personal_data as crud

router = APIRouter()


@router.post("/", response_model=UserPersonalData, status_code=201)
def create_user(user: UserPersonalDataCreate, db: Session = Depends(get_db)):
    db_user = crud.get_user_by_email(db, user.email)
    if db_user:
        # Если пользователь есть, но не подтвержден - можно пересоздать код (опционально)
        # Но пока просто вернем ошибку
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db, user)

@router.post("/verify", status_code=200)
def verify_email(data: UserVerifyEmail, db: Session = Depends(get_db)):
    result = crud.verify_user_email(db, data.email, data.code)

    if result is None:
        raise HTTPException(status_code=404, detail="User not found")

    if result is False:
        raise HTTPException(status_code=400, detail="Invalid verification code")

    return {"message": "Email verified successfully"}

@router.get("/", response_model=List[UserPersonalData])
def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_users(db, skip=skip, limit=limit)


@router.get("/{user_id}/", response_model=UserPersonalData)
def read_user(user_id: int, db: Session = Depends(get_db)):
    user = crud.get_user_by_id(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_reading_records.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_reading_records import UserReadingRecord, UserReadingRecordCreate
from app.crud import users_reading_records as crud

router = APIRouter()

@router.post("/", response_model=UserReadingRecord, status_code=201)
def create_record(record: UserReadingRecordCreate, db: Session = Depends(get_db)):
    return crud.create_record(db, record)

@router.get("/", response_model=List[UserReadingRecord])
def read_records(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_records(db, skip=skip, limit=limit)

@router.get("/{record_id}/", response_model=UserReadingRecord)
def read_record(record_id: int, db: Session = Depends(get_db)):
    record = crud.get_record(db, record_id)
    if not record:
        raise HTTPException(status_code=404, detail="Record not found")
    return record


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_statistics.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_statistics import UserStatistics, UserStatisticsCreate
from app.crud import users_statistics as crud

router = APIRouter()

@router.post("/", response_model=UserStatistics, status_code=201)
def create_statistics(stats: UserStatisticsCreate, db: Session = Depends(get_db)):
    return crud.create_statistics(db, stats)

@router.get("/", response_model=List[UserStatistics])
def read_statistics(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_statistics(db, skip=skip, limit=limit)

@router.get("/{stats_id}/", response_model=UserStatistics)
def read_statistics_by_id(stats_id: int, db: Session = Depends(get_db)):
    stats = crud.get_statistics_by_id(db, stats_id)
    if not stats:
        raise HTTPException(status_code=404, detail="Statistics not found")
    return stats

@router.get("/user/{user_id}", response_model=UserStatistics)
def read_user_statistics(user_id: int, db: Session = Depends(get_db)):
    stats = crud.get_statistics_by_user_id(db, user_id)
    if not stats:
        # Если статистики нет, возвращаем пустую (нулевую) структуру, чтобы фронт не падал
        return UserStatistics(
            id=0, user_id=user_id,
            books_in_library=0, books_read=0, books_favorites=0,
            favorite_author="-", favorite_genre="-"
        )
    return stats


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\users_top_characters.py =====

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.db.session import get_db
from app.schemas.users_top_characters import UserTopCharacters, UserTopCharactersCreate
from app.crud import users_top_characters as crud

router = APIRouter()

@router.post("/", response_model=UserTopCharacters, status_code=201)
def create_top_characters(top_chars: UserTopCharactersCreate, db: Session = Depends(get_db)):
    return crud.create_top_characters(db, top_chars)

@router.get("/", response_model=List[UserTopCharacters])
def read_top_characters(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_top_characters(db, skip=skip, limit=limit)

@router.get("/{record_id}/", response_model=UserTopCharacters)
def read_top_characters_by_id(record_id: int, db: Session = Depends(get_db)):
    record = crud.get_top_characters_by_id(db, record_id)
    if not record:
        raise HTTPException(status_code=404, detail="Top characters record not found")
    return record


===== D:\BSUIR\Diploma\OwlReads-project\server-OwlReads\app\api\__init__.py =====

